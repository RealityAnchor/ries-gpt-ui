[{"role": "system", "content": "Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n        \n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n        self.input_focus = True\n\n        self.border_size = 8\n        self.chat_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLE)\n        self.chat_box.config(insertbackground=\"#975\")\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#6666ff\")\n        \n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.input_box.config(insertbackground=\"#975\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.toggle_input()\n\n        # keyboard shortcuts\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_input)\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<Control-f>', self.filter_history)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n        \n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n\n    def toggle_input(self, event=None):\n        if self.input_focus == True:\n            self.input_box.focus_set()\n        else:\n            self.chat_box.focus_set()\n        self.input_focus = not self.input_focus\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        \n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n        \n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            print(token_lengths.pop(0))\n\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        \n    def save_history(self):\n        with open(f'history/history_{self.timestamp}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(f)\n\n    def load_history(self, filename):\n        with open(f'history/{filename}', 'r') as f:\n            self.history = json.load(f)\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        self.update_title(f)\n\n    def update_display(self):\n        self.chat_box.config(state=NORMAL)\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.config(state=DISABLED)\n\n    def filter_history(self, event=None):\n        query = simpledialog.askstring(\"Filter History\", \"String:\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.json_files)\n\n    def populate_history(self, files):    \n        self.history_menu.delete(0, END)\n        for f in sorted(files, reverse=True):\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "The code is a Python program that creates a chatbot GUI using the tkinter library, interfacing GPT-3.5-turbo API, and saving chat history to JSON files. The chatbot can take user input and generate responses using the GPT-3 API. It has a GUI interface consisting of a chat box in the top half and an input area in the bottom half. It also has functionalities including keyboard shortcuts, history filtering, and saving chat history."}, {"role": "user", "content": "how to disable editing in the chatbox"}, {"role": "assistant", "content": "To disable editing in the chatbox, you can set the `state` attribute of the `Text` widget to `DISABLED`. This makes the widget read-only and it cannot be edited by the user. \n\nIn this code, the chatbox is already configured with this attribute in the `__init__` function:\n```\nself.chat_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLE)\n```\nTherefore, the chatbox is already read-only by default."}, {"role": "user", "content": "augment ctrl-f filter_history\nadd new box to search the content of messages in self.history instead of all the history json files\nfor the new box, jump to matching strings in chatbox"}, {"role": "assistant", "content": "To add a new box for searching the content of messages in `self.history` and jump to matching strings in the chatbox, you can modify the `filter_history` function in the code. Here's an updated version of the function:\n\n```\ndef filter_history(self, event=None):\n    query = simpledialog.askstring(\"Filter History\", \"String:\")\n    if query:\n        matching_entries = []\n        for entry in self.history:\n            content = entry[\"content\"]\n            if query.lower() in content.lower():\n                matching_entries.append(entry)\n\n        if matching_entries:\n            self.history_menu_var.set(f\"History ({len(matching_entries)})\")\n            self.history_menu.delete(0, END)\n            for entry in matching_entries:\n                file_size = round(len(entry[\"content\"]) / 1024, 1)\n                self.history_menu.add_command(label=f\"{entry['content'][:30]}... ({file_size} KB)\", command=lambda m_entry=entry: self.jump_to_entry(m_entry))\n        else:\n            self.history_menu_var.set(\"History\")\n\n    else:\n        self.history_menu_var.set(\"History\")\n\ndef jump_to_entry(self, entry):\n    index = \"1.0\"\n    while True:\n        index = self.chat_box.search(entry[\"content\"], index, nocase=True, stopindex=END)\n        if not index:\n            break\n        end_index = f\"{index}+{len(entry['content'])}c\"\n        self.chat_box.tag_add(\"highlight\", index, end_index)\n        index = end_index\n    self.chat_box.tag_configure(\"highlight\", background=\"yellow\", foreground=\"black\")\n    self.chat_box.see(end_index)\n```\n\nThis function prompts the user for a search query and then iterates over each `entry` in `self.history` to find the ones that match the query. It then updates the `history_menu` to display the matching entries and sets their commands to jump to that entry in the chat box. \n\nThe `jump_to_entry` function uses the `search` method of the chat_box widget to find the index of the matching string and adds a `highlight` tag to that section of text. It then configures the `highlight` tag to have a yellow background and black foreground. Finally, it uses the `see` method to jump to the end of the matching section of text."}]