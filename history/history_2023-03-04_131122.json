[{"role": "system", "content": "Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate."}, {"role": "user", "content": "yes, but i want to do it differently than how you suggested"}, {"role": "assistant", "content": "Sure! Feel free to do it differently. Could you please explain the approach that you want to take?"}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom chatgpt import GPT\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#000\")\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<Control-f>', self.filter_history)\n        \n        self.preprompt = \"Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate.\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.engine = \"gpt-3.5-turbo\"\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n        \n        self.chat_box = Text(master, wrap=WORD, width=80, height=20, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#997755\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#6666ff\")\n\n        self.input_box = Text(master, wrap=WORD, width=80, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.input_box.config(insertbackground=\"#888\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=8, pady=8)\n        self.input_box.focus_set()\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#997755')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#997755')\n        \n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = GPT(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 10))\n        self.chat_box.see(END)\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.all_json_files = sorted([f for f in os.listdir('history/') if f.startswith(\"history_\")], reverse=True)\n        self.populate_history(self.all_json_files)\n        self.update_display()\n        \n    def save_history(self):\n        with open(f'history/history_{self.timestamp}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(f)\n\n    def load_history(self, filename):\n        with open(f'history/{filename}', 'r') as f:\n            self.history = json.load(f)\n        self.update_display()\n        self.update_title(f)\n\n    def update_display(self):\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.see(END)\n\n    def filter_history(self, event=None):\n        query = simpledialog.askstring(\"Filter History\", \"String:\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.all_json_files)\n\n    def populate_history(self, files):    \n        self.history_menu.delete(0, END)\n        for f in files:\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "Okay, what approach do you have in mind?"}, {"role": "user", "content": "how to implement ctrl+s feature to save favourites in menubar dropdown beside History"}, {"role": "assistant", "content": "To add a \"Save Favorites\" option in your menu bar, you can first create a command for the menu item. This command should prompt the user to input a name for the favorite and then save the current conversation history as a JSON file using that name.\n\nHere's an example of how you could modify the `ChatBot` class to accomplish this:\n\n```python\nclass ChatBot:\n    def __init__(self, master):\n        # ...\n        self.history_menu.add_command(label=\"Save Favorite\", command=self.save_favorite)\n        # ...\n\n    def save_favorite(self):\n        name = simpledialog.askstring(\"Save Favorite\", \"Name:\")\n        if not name:\n            return\n\n        with open(f'favorites/{name}.json', 'w') as f:\n            json.dump(self.history, f)\n\n        self.populate_favorites()\n\n    def populate_favorites(self):\n        self.favorites_menu.delete(0, END)\n        favorites = []\n        for f in os.listdir('favorites/'):\n            if f.endswith('.json'):\n                favorites.append(f)\n\n        favorites = sorted(favorites, key=lambda f: os.path.getmtime(f'favorites/{f}'), reverse=True)\n\n        for f in favorites:\n            file_size = round(os.path.getsize(f'favorites/{f}') / 1024, 1)\n            self.favorites_menu.add_command(label=f\"{f[:-5]} ({file_size} KB)\", command=lambda hf=f: self.load_favorite(hf))\n        self.menu.delete(2)\n        self.menu.add_cascade(label=f\"Favorites ({len(favorites)})\", menu=self.favorites_menu, underline=0)\n```\n\nHere, we add a \"Save Favorite\" option to the `history_menu` and bind it to the `save_favorite` method. This method prompts the user to enter a name for the favorite using a dialog box. If the input isn't empty, it saves the current history to a JSON file with the desired name in a \"favorites\" directory.\n\nWe also add a `populate_favorites` method that reads the list of favorite files in the \"favorites\" directory, sorts them by modification time, and populates the `favorites_menu` with the appropriate entries. Finally, we add the `Favorites` option to the main menu."}]