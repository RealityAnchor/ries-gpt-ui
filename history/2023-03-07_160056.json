[{"role": "system", "content": "Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n\n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n\n        self.border_size = 8\n        self.thread_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLED)\n        self.thread_box.bind(\"<FocusIn>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.bind(\"<FocusOut>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.thread_box.tag_configure(\"user\", foreground=\"#555\")\n        self.thread_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.thread_box.tag_configure(\"system\", foreground=\"#66f\")\n        self.thread_box.tag_configure(\"highlight\", background=\"#66f\", foreground=\"#000\")\n\n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#888\", bg=\"#000\", font=(\"Arial\", 14), insertbackground=\"#888\")\n        self.input_box.bind(\"<FocusIn>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.bind(\"<FocusOut>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.input_box.focus_set()\n\n        # KEYBOARD SHORTCUTS\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_box_focus)\n        master.bind('<Control-f>', self.find_string)\n        master.bind('<Control-h>', self.history_filter)\n        master.bind('<Control-s>', self.rename_thread)\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<F11>', self.toggle_fullscreen)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n\n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n\n    def toggle_bg_colour(self, box, event=None):\n        if event.type == \"9\": # <FocusIn>\n            box.config(background=\"#111\")\n        elif event.type == \"10\": # <FocusOut>\n            box.config(background=\"#000\")\n\n\n    # Return\n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n\n        # slice oldest messages from overly long threads\n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            token_lengths.pop(0)\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # Shift-Return\n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n\n    # Ctrl-E\n    def toggle_box_focus(self, event=None):\n        if self.master.focus_get() == self.input_box:\n            self.thread_box.focus_set()\n        else:\n            self.input_box.focus_set()\n\n    # Ctrl-F\n    def find_string(self, event=None):\n        query = simpledialog.askstring(\"Find String\", \"\")\n        if query:\n            index = \"1.0\"\n            first_match_index = None\n            while True:\n                index = self.thread_box.search(query, index, nocase=True, stopindex=END)\n                if not index:\n                    break\n                end_index = f\"{index}+{len(query)}c\"\n                self.thread_box.tag_add(\"highlight\", index, end_index)\n                if first_match_index is None:\n                    first_match_index = index\n                index = end_index\n            if first_match_index is not None:\n                self.thread_box.see(first_match_index)\n\n    # Ctrl-H\n    # searches json files for a string\n    def history_filter(self, event=None):\n        query = simpledialog.askstring(\"History Filter\", \"\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.json_files)\n\n    # Ctrl-S\n    def rename_thread(self, event=None):\n        old_name = self.master.title()\n        if old_name.endswith('*'):\n            old_name = old_name[:-1]\n        query = simpledialog.askstring(\"Rename Thread\", \"\", initialvalue=old_name)\n        if query:\n            if not query.endswith(\".json\"):\n                query += \".json\"\n            if query == old_name:\n                return\n            for f in self.files_with_json_ext:\n                if f.lower() == query.lower():\n                    overwrite = simpledialog.askstring(\"File exists\", \"A file with the same name already exists. Do you want to overwrite it? (yes/no)\", initialvalue=\"no\")\n                    if overwrite.lower() == \"no\":\n                        return\n                    os.remove(f\"history/{f}\")\n            os.rename(f\"history/{old_name}\", f\"history/{query}\")\n            self.master.title(query)\n\n    # F5\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n\n    # F11\n    def toggle_fullscreen(self, event=None):\n        self.master.attributes('-fullscreen', not self.master.attributes('-fullscreen'))\n\n    # Key-Release\n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n\n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def save_history(self):\n        with open(f'history/history_{self.timestamp}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(f)\n\n    def load_history(self, filename):\n        with open(f'history/{filename}', 'r') as f:\n            self.history = json.load(f)\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        self.update_title(f)\n\n    def update_display(self):\n        self.thread_box.config(state=NORMAL)\n        self.thread_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.thread_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.thread_box.config(state=DISABLED)\n        self.thread_box.see(END)\n\n    def populate_history(self, files):\n        self.history_menu.delete(0, END)\n        for f in sorted(files, reverse=True):\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "The code defines a GUI Chatbot using the following modules: tkinter, simpledialog, datetime, json, os, threading, and tiktoken. It provides functionality to create a new conversation, rename conversation, search history files for a string, find a specific text within the chat, toggle fullscreen, and toggle box focus. It also shows messages in different colours using tags \"user\", \"bot\", and \"system\". The GPT-3 API is being used to generate responses, and conversations are saved to disk as JSON files in a \"history\" folder."}, {"role": "user", "content": "properly implement ctrl-s\nreply only with new/changed/deleted lines (specify)\nin the final implementation, files should automatically be saved with timestamp the first time a message is sent (\"history/{timestamp}\", not \"history/history_{timestamp})\nthereafter, files should be saved with their current name every time a message is sent\nctrl-s changes the current name of the current file to a user-specified string. in case of duplicate names, append _2 _3 _4 _5 ... _11 _12 ... etc until you reach a name that doesn't currently exist in folder. don't ask user to confirm"}, {"role": "assistant", "content": "Changes:\n- Added a `save_as` function to save the current conversation with a new name.\n- Added a `save_history` call when sending a message to save the current session's conversation to the current name.\n- Changed `timestamp` to `filename`, where the filename corresponds to the current name of the conversation.\n- The first message of every new conversation is automatically saved to a file with the name specified by the user.\n- Files are saved to disk as \"history/{filename}.json\".\n- Pressing \"Ctrl-S\" now calls the new `save_as` function instead.\n\n```python\nclass ChatBot:\n    def __init__(self, master):\n        ...\n        self.filename = \"\"\n        ...\n\n    def save_history(self):\n        if self.filename:\n            with open(f\"history/{self.filename}.json\", 'w') as f:\n                json.dump(self.history, f)\n\n    # Ctrl-S\n    def save_as(self, event=None):\n        new_filename = simpledialog.askstring(\"Rename Conversation\", \"\")\n        if new_filename:\n            # check for duplicates\n            existing_files = [f.rsplit(\".\", 1)[0] for f in os.listdir('history/')]\n            new_filename = new_filename.rstrip(\".json\") + \".json\"\n            i = 2\n            while new_filename in existing_files:\n                new_filename = f\"{new_filename.rsplit('_', 1)[0]}_{i}.json\"\n                i += 1\n\n            # rename file and update menu\n            os.rename(f\"history/{self.filename}.json\", f\"history/{new_filename}\")\n            self.filename = new_filename.rsplit(\".\", 1)[0]\n            self.update_title(f\"history/{self.filename}.json\")\n            self.populate_history(self.json_files)\n\n            # save current conversation to new file\n            with open(f\"history/{self.filename}.json\", 'w') as f:\n                json.dump(self.history, f)\n```"}, {"role": "user", "content": "self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n\ntest for ending in json instead of starting with history"}, {"role": "assistant", "content": "Changed line:\n```\nself.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n```\n\nto:\n\n```\nself.json_files = [f for f in os.listdir('history/') if f.endswith(\".json\")]\n``` \n\nThis line now looks for files with an \".json\" extension instead of those starting with \"history_\"."}]