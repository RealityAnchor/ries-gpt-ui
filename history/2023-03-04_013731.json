[{"role": "system", "content": "Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate."}, {"role": "user", "content": "from tkinter import *\nfrom chatgpt import GPT\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#000\")\n        master.bind('<F5>', self.new_history)\n        \n        self.preprompt = \"Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate.\"\n        self.engine = \"gpt-3.5-turbo\"\n\n        self.history_dir = 'history/'\n        self.history_json_files = sorted([f for f in os.listdir(self.history_dir) if f.startswith(\"history_\")], reverse=True)\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n        \n        self.chat_box = Text(master, wrap=WORD, width=80, height=20, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#997755\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#6666ff\")\n\n        self.input_box = Text(master, wrap=WORD, width=80, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.input_box.config(insertbackground=\"#888\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=8, pady=8)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        self.input_box.focus_set()\n        \n        self.new_history()\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#997755')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#997755')\n        \n        menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        history_menu = Menu(menu, tearoff=1)\n\n        for history_file in self.history_json_files:\n            file_size = round(os.path.getsize(f'history/{history_file}') / 1024, 1)\n            history_menu.add_command(label=f\"{history_file} ({file_size} KB)\", command=lambda hf=history_file: self.load_history(hf))\n\n        menu.add_cascade(label=\"History\", menu=history_menu)\n\n        master.config(menu=menu)\n\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = GPT(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.display_history)\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 10))\n        self.chat_box.see(END)\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.display_history()\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self):\n        file_size = round(os.path.getsize(f'{self.history_file}') / 1024, 1)\n        self.master.title(f\"{self.history_file} ({file_size} KB)\")\n    \n    def new_history(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.history_file = f\"{self.history_dir}history_{datetime.now().strftime('%Y-%m-%d_%H%M%S')}.json\"\n        self.display_history()\n        \n    def save_history(self):\n        with open(self.history_file, 'w') as f:\n            json.dump(self.history, f)\n        self.update_title()\n\n    def load_history(self, filename):\n        with open(self.history_dir + filename, 'r') as f:\n            self.history = json.load(f)\n        self.display_history()\n        self.update_title()\n\n    def display_history(self):\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.see(END)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "This is a Python class for a chatbot interface using tkinter and GPT-3. The chatbot allows users to send messages and receive responses from GPT-3, while also keeping a record of the conversation history. The chatbot interface has two text boxes for displaying conversation history and for users to input their messages, respectively. It also has a menu that displays the available conversation history files for loading. \n\nThe `gpt_call()` method makes a call to GPT-3 using an engine and conversation history as arguments. The method then appends the response from GPT-3 to the conversation history and saves the entire history to a JSON file using the `save_history()` method. \n\nThe `new_history()` method creates a new conversation history file and sets the initial message prompt to the `self.preprompt` variable. \n\nThe `load_history()` method loads a conversation history file by parsing a JSON file and populating the conversation history. \n\nThe main function that runs the tkinter chatbot interface is instantiated with `Tk()` and then a new chatbot object is created with `my_gui = ChatBot(root)` before the main loop with `root.mainloop()`."}, {"role": "user", "content": "add ctrl-f popup search feature. after user enters search phrase, use get_files(f'{os.getcwd()}/history', query) which will return a list of filenames matching the query\nrepopulate the History menu with only the matching files"}, {"role": "assistant", "content": "To add the search feature, we first need to create a new function `search_files()` that will take a query string and search for filename matches in the `history/` directory using the `get_files()` function from the `json_search` module. This function will return a list of file paths that match the query.\n\nWe can then create a new method called `search_history()` in the `ChatBot` class, which will prompt the user to enter a search phrase and call the `search_files()` function. The returned list of file paths can then be used to repopulate the History menu with only the matching files.\n\nTo implement the Ctrl-F popup search feature, we can bind the `<Control-f>` keystroke to the `search_history()` method. This can be done in the constructor of the `ChatBot` class using the `bind()` method of the `master` instance.\n\nHere's the updated implementation:\n\n```python\nfrom tkinter import *\nfrom chatgpt import GPT\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#000\")\n        master.bind('<F5>', self.new_history)\n        master.bind('<Control-f>', self.search_history)\n        \n        self.preprompt = \"Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate.\"\n        self.engine = \"gpt-3.5-turbo\"\n\n        self.history_dir = 'history/'\n        self.history_json_files = sorted([f for f in os.listdir(self.history_dir) if f.startswith(\"history_\")], reverse=True)\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n        \n        self.chat_box = Text(master, wrap=WORD, width=80, height=20, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#997755\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#6666ff\")\n\n        self.input_box = Text(master, wrap=WORD, width=80, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.input_box.config(insertbackground=\"#888\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=8, pady=8)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        self.input_box.focus_set()\n        \n        self.new_history()\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#997755')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#997755')\n        \n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        \n        self.populate_history_menu(self.history_json_files)\n\n        master.config(menu=self.menu)\n\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = GPT(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.display_history)\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 10))\n        self.chat_box.see(END)\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.display_history()\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self):\n        file_size = round(os.path.getsize(f'{self.history_file}') / 1024, 1)\n        self.master.title(f\"{self.history_file} ({file_size} KB)\")\n    \n    def new_history(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.history_file = f\"{self.history_dir}history_{datetime.now().strftime('%Y-%m-%d_%H%M%S')}.json\"\n        self.display_history()\n        \n    def save_history(self):\n        with open(self.history_file, 'w') as f:\n            json.dump(self.history, f)\n        self.update_title()\n\n    def load_history(self, filename):\n        with open(self.history_dir + filename, 'r') as f:\n            self.history = json.load(f)\n        self.display_history()\n        self.update_title()\n\n    def display_history(self):\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.see(END)\n\n    def search_history(self, event=None):\n        query = simpledialog.askstring(\"Search\", \"Search History:\")\n        if query:\n            files = get_files(f'{os.getcwd()}/history', query)\n            self.populate_history_menu(files)\n\n    def populate_history_menu(self, files):    \n        self.history_menu.delete(0, END)\n        for history_file in files:\n            file_size = round(os.path.getsize(f'history/{history_file}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{history_file} ({file_size} KB)\", command=lambda hf=history_file: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=\"History\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()\n```\n\nI have added a new `search_history()` method and a call to it with the `<Control-f>` keystroke in the constructor of the `ChatBot` class using the `bind()` method of the `master` instance.\n\nThe `search_history()` method prompts the user to enter a search phrase, and then calls the `get_files()` function from the `json_search` module to search for matches in the `history/` directory. The returned list of file paths is then used to repopulate the History menu with only the matching files using the `populate_history_menu()` method.\n\nThe `populate_history_menu()` method takes a list of file paths and uses it to clear and repopulate the `self.history_menu` instance variable with only the matching files. The `self.menu` instance variable is also cleared and repopulated with the updated `self.history_menu`."}, {"role": "user", "content": "Exception in Tkinter callback\nTraceback (most recent call last):\n  File \"C:\\Users\\Adam\\AppData\\Local\\Programs\\Python\\Python38\\lib\\tkinter\\__init__.py\", line 1883, in __call__\n    return self.func(*args)\n  File \"C:\\Users\\Adam\\Desktop\\OpenAI\\ChatGPT-A\\LocalChat\\localchat.py\", line 123, in search_history\n    query = simpledialog.askstring(\"Search\", \"Search History:\")\nNameError: name 'simpledialog' is not defined"}, {"role": "assistant", "content": "It looks like the `simpledialog` module is not imported in the code. \n\nYou can add the following import statement at the top of your Python file:\n\n```python\nfrom tkinter import simpledialog\n```\n\nThis should resolve the `NameError` exception you encountered with the `simpledialog` module."}]