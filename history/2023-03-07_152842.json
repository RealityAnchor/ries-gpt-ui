[{"role": "system", "content": "Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n\n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n\n        self.border_size = 8\n        self.thread_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLED)\n        self.thread_box.bind(\"<FocusIn>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.bind(\"<FocusOut>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.thread_box.tag_configure(\"user\", foreground=\"#555\")\n        self.thread_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.thread_box.tag_configure(\"system\", foreground=\"#66f\")\n        self.thread_box.tag_configure(\"highlight\", background=\"#66f\", foreground=\"#000\")\n\n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#888\", bg=\"#000\", font=(\"Arial\", 14), insertbackground=\"#888\")\n        self.input_box.bind(\"<FocusIn>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.bind(\"<FocusOut>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.input_box.focus_set()\n\n        # KEYBOARD SHORTCUTS\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_box_focus)\n        master.bind('<Control-f>', self.find_string)\n        master.bind('<Control-h>', self.history_filter)\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<F11>', self.toggle_fullscreen)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n\n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n\n    def toggle_bg_colour(self, box, event=None):\n        if event.type == \"9\": # <FocusIn>\n            box.config(background=\"#111\")\n        elif event.type == \"10\": # <FocusOut>\n            box.config(background=\"#000\")\n\n\n    # RETURN\n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n\n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            token_lengths.pop(0)\n\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # Shift-Return\n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n\n    # Ctrl-E\n    def toggle_box_focus(self, event=None):\n        if self.master.focus_get() == self.input_box:\n            self.thread_box.focus_set()\n        else:\n            self.input_box.focus_set()\n\n    # CTRL-F\n    def find_string(self, event=None):\n        query = simpledialog.askstring(\"Find String\", \"\")\n        if query:\n            index = \"1.0\"\n            first_match_index = None\n            while True:\n                index = self.thread_box.search(query, index, nocase=True, stopindex=END)\n                if not index:\n                    break\n                end_index = f\"{index}+{len(query)}c\"\n                self.thread_box.tag_add(\"highlight\", index, end_index)\n                if first_match_index is None:\n                    first_match_index = index\n                index = end_index\n            if first_match_index is not None:\n                self.thread_box.see(first_match_index)\n\n    # CTRL-H\n    # searches json files for a string\n    def history_filter(self, event=None):\n        query = simpledialog.askstring(\"History Filter\", \"\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.json_files)\n\n    # F5\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n\n    # F11\n    def toggle_fullscreen(self, event=None):\n        self.master.attributes('-fullscreen', not self.master.attributes('-fullscreen'))\n\n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n\n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def save_history(self):\n        with open(f'history/history_{self.timestamp}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(f)\n\n    def load_history(self, filename):\n        with open(f'history/{filename}', 'r') as f:\n            self.history = json.load(f)\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        self.update_title(f)\n\n    def update_display(self):\n        self.thread_box.config(state=NORMAL)\n        self.thread_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.thread_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.thread_box.config(state=DISABLED)\n        self.thread_box.see(END)\n\n    def populate_history(self, files):\n        self.history_menu.delete(0, END)\n        for f in sorted(files, reverse=True):\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "The code is a Python program that creates a graphical user interface (GUI) for a chatbot application called ChatGPT. The chatbot uses the GPT-3.5-Turbo language model to generate responses to user input. The GUI consists of two text boxes - one for displaying the conversation thread and another for entering user input - and a menu for accessing conversation history files. The program includes keyboard shortcuts for various features, including toggling between input and output boxes, finding text in the conversation thread, filtering the conversation history, starting a new conversation thread, and toggling fullscreen mode. The GUI is styled with customized colors and font preferences."}, {"role": "user", "content": "add ctrl-s function to rename current thread's history json file with a custom name\ninstead of `if f.startswith(\"history_\")` test for files that have .json extension\ninstead of `with open(f'history/history_{self.timestamp}.json', 'w') as f:`, redesign the program so that existing history threads keep their current name by default. only use timestamp when saving a new thread for the first time, and remove 'history_' at start of filename so that the full filename is just the timestamp. only change an existing json filename when user presses ctrl-s"}, {"role": "assistant", "content": "Here is the modified code that includes the new features:\n\n```python\nfrom tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n\n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.files_with_json_ext = []\n\n        self.border_size = 8\n        self.thread_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLED)\n        self.thread_box.bind(\"<FocusIn>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.bind(\"<FocusOut>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.thread_box.tag_configure(\"user\", foreground=\"#555\")\n        self.thread_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.thread_box.tag_configure(\"system\", foreground=\"#66f\")\n        self.thread_box.tag_configure(\"highlight\", background=\"#66f\", foreground=\"#000\")\n\n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#888\", bg=\"#000\", font=(\"Arial\", 14), insertbackground=\"#888\")\n        self.input_box.bind(\"<FocusIn>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.bind(\"<FocusOut>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.input_box.focus_set()\n\n        # KEYBOARD SHORTCUTS\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_box_focus)\n        master.bind('<Control-f>', self.find_string)\n        master.bind('<Control-h>', self.history_filter)\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<F11>', self.toggle_fullscreen)\n        master.bind('<Control-s>', self.rename_thread)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n\n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n\n    def toggle_bg_colour(self, box, event=None):\n        if event.type == \"9\": # <FocusIn>\n            box.config(background=\"#111\")\n        elif event.type == \"10\": # <FocusOut>\n            box.config(background=\"#000\")\n\n    # RETURN\n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n\n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            token_lengths.pop(0)\n\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # Shift-Return\n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n\n    # Ctrl-E\n    def toggle_box_focus(self, event=None):\n        if self.master.focus_get() == self.input_box:\n            self.thread_box.focus_set()\n        else:\n            self.input_box.focus_set()\n\n    # CTRL-F\n    def find_string(self, event=None):\n        query = simpledialog.askstring(\"Find String\", \"\")\n        if query:\n            index = \"1.0\"\n            first_match_index = None\n            while True:\n                index = self.thread_box.search(query, index, nocase=True, stopindex=END)\n                if not index:\n                    break\n                end_index = f\"{index}+{len(query)}c\"\n                self.thread_box.tag_add(\"highlight\", index, end_index)\n                if first_match_index is None:\n                    first_match_index = index\n                index = end_index\n            if first_match_index is not None:\n                self.thread_box.see(first_match_index)\n\n    # CTRL-H\n    # searches json files for a string\n    def history_filter(self, event=None):\n        query = simpledialog.askstring(\"History Filter\", \"\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.files_with_json_ext)\n\n    # F5\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.files_with_json_ext = [f for f in os.listdir('history/') if f.endswith(\".json\")]\n        self.populate_history(self.files_with_json_ext, keep_title=True)\n        self.update_display()\n\n    # F11\n    def toggle_fullscreen(self, event=None):\n        self.master.attributes('-fullscreen', not self.master.attributes('-fullscreen'))\n\n    # Ctrl-S\n    def rename_thread(self, event=None):\n        old_name = self.master.title()\n        if old_name.endswith('*'):\n            old_name = old_name[:-1]\n        query = simpledialog.askstring(\"Rename Thread\", \"\", initialvalue=old_name)\n        if query:\n            if not query.endswith(\".json\"):\n                query += \".json\"\n            if query == old_name:\n                return\n            for f in self.files_with_json_ext:\n                if f.lower() == query.lower():\n                    overwrite = simpledialog.askstring(\"File exists\", \"A file with the same name already exists. Do you want to overwrite it? (yes/no)\", initialvalue=\"no\")\n                    if overwrite.lower() == \"no\":\n                        return\n                    os.remove(f\"history/{f}\")\n            os.rename(f\"history/{old_name}\", f\"history/{query}\")\n            self.master.title(query)\n\n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n\n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def save_history(self):\n        if not self.master.title().endswith('*'):\n            self.master.title(f\"{self.master.title()}*\")\n            with open(f'history/{self.master.title()}', 'w') as f:\n                json.dump(self.history, f)\n            self.update_title(f)\n\n    def load_history(self, filename):\n"}]