[{"role": "system", "content": "Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n        \n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only new, changed, or deleted lines and specify which is which.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n\n        self.border_size = 8\n        self.chat_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLED, insertbackground=\"#975\")\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#66f\")\n        self.chat_box.tag_configure(\"highlight\", background=\"#66f\", foreground=\"#000\")\n        \n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), insertbackground=\"#975\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.input_box.focus_set()\n        self.selected_box = self.input_box\n\n        # KEYBOARD SHORTCUTS\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_box_focus)\n        master.bind('<Control-f>', self.find_string)\n        master.bind('<Control-h>', self.history_filter)\n        master.bind('<F5>', self.new_conversation)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n        \n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.new_conversation()\n\n        master.config(menu=self.menu)\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.update_display)\n\n    def highlight_selected_widget(self, widget):\n        if self.selected_widget:\n            self.selected_widget.config(background=\"#999\")\n        widget.config(highlightthickness=1, highlightbackground=\"#999\")\n        self.selected_widget = widget\n\n    def toggle_box_focus(self, event=None):\n        if self.selected_box == self.input_box:\n            self.input_box.config(background=\"#000\")\n            self.chat_box.config(background=\"#111\")\n            self.selected_box = self.chat_box\n            self.chat_box.focus_set()\n        elif self.selected_box == self.chat_box:\n            self.chat_box.config(background=\"#000\")\n            self.input_box.config(background=\"#111\")\n            self.selected_box = self.input_box\n            self.input_box.focus_set()\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        \n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.update_display()\n        \n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            print(token_lengths.pop(0))\n\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self, file):\n        file_size = round(os.path.getsize(file.name) / 1024, 1)\n        self.master.title(f\"{file.name} ({file_size} KB)\")\n\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        \n    def save_history(self):\n        with open(f'history/history_{self.timestamp}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(f)\n\n    def load_history(self, filename):\n        with open(f'history/{filename}', 'r') as f:\n            self.history = json.load(f)\n        self.json_files = [f for f in os.listdir('history/') if f.startswith(\"history_\")]\n        self.populate_history(self.json_files)\n        self.update_display()\n        self.update_title(f)\n\n    def update_display(self):\n        self.chat_box.config(state=NORMAL)\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.config(state=DISABLED)\n        self.chat_box.see(END)\n\n    # CTRL-F\n    def find_string(self, event=None):\n        query = simpledialog.askstring(\"Find String\", \"\")\n        if query:\n            index = \"1.0\"\n            first_match_index = None\n            while True:\n                index = self.chat_box.search(query, index, nocase=True, stopindex=END)\n                if not index:\n                    break\n                end_index = f\"{index}+{len(query)}c\"\n                self.chat_box.tag_add(\"highlight\", index, end_index)\n                if first_match_index is None:\n                    first_match_index = index\n                index = end_index\n            if first_match_index is not None:\n                self.chat_box.see(first_match_index)\n\n    # CTRL-H\n    # searches json files for a string\n    def history_filter(self, event=None):\n        query = simpledialog.askstring(\"History Filter\", \"\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.json_files)\n\n    def populate_history(self, files):    \n        self.history_menu.delete(0, END)\n        for f in sorted(files, reverse=True):\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "The code is a Python class that implements a chatbot using OpenAI's GPT-3 API. The chatbot has a graphical user interface (GUI) built using the tkinter library. The GUI displays a chat history and allows users to type a message to the chatbot. The chatbot responds using GPT-3's natural language generation capabilities. The chat history can be saved and loaded to/from JSON files, and a search function is implemented to find specific strings in the chat history. The GUI also allows keyboard shortcuts for toggling between input and chat history boxes, and for finding strings in the chat history."}, {"role": "user", "content": "how to alter code so that the correct box is always highlighted?\nit currently works with ctrl-e but doesn't detect when i click inside\n\n\n        self.chat_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus())\n        self.input_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus())\n\nthese two lines almost work but cause an infinite loop, because FocusIn is triggered when `self.input_box.focus_set()` runs\n\nredesign the code to make ctrl-e work as it currently does, but also detect when focus changes for other reasons, but without infinitely looping"}, {"role": "assistant", "content": "To avoid the infinite loop, you can define a class variable `self.is_input_box_focused` and check its value in the `toggle_box_focus()` method. \n\n```\ndef __init__(self, master):\n    ...\n    self.is_input_box_focused = False\n\n    self.chat_box.bind(\"<FocusIn>\", self.chat_box_focus_in)\n    self.chat_box.bind(\"<FocusOut>\", self.chat_box_focus_out)\n    self.input_box.bind(\"<FocusIn>\", self.input_box_focus_in)\n    self.input_box.bind(\"<FocusOut>\", self.input_box_focus_out)\n\ndef chat_box_focus_in(self, event=None):\n    self.is_input_box_focused = False\n\ndef chat_box_focus_out(self, event=None):\n    if self.is_input_box_focused:\n        self.toggle_box_focus()\n\ndef input_box_focus_in(self, event=None):\n    self.is_input_box_focused = True\n\ndef input_box_focus_out(self, event=None):\n    if not self.is_input_box_focused:\n        self.toggle_box_focus()\n\ndef toggle_box_focus(self, event=None):\n    if self.selected_box == self.input_box:\n        if not self.is_input_box_focused:\n            self.input_box.config(background=\"#000\")\n            self.chat_box.config(background=\"#111\")\n        self.selected_box = self.chat_box\n        self.chat_box.focus_set()\n    elif self.selected_box == self.chat_box:\n        if self.is_input_box_focused:\n            self.input_box.config(background=\"#111\")\n            self.chat_box.config(background=\"#000\")\n        self.selected_box = self.input_box\n        self.input_box.focus_set()\n```\n\nIn this solution, when the chat box is focused, we set `self.is_input_box_focused = False`, and when the input box is focused, we set `self.is_input_box_focused = True`. When the chat box loses focus, we only call `self.toggle_box_focus()` if `self.is_input_box_focused` is True. Similarly, when the input box loses focus, we only call `self.toggle_box_focus()` if `self.is_input_box_focused` is False.\n\nThis way, we can use keyboard shortcuts such as `Ctrl-E` and clicking inside the boxes to toggle focus without causing an infinite loop."}, {"role": "user", "content": "that looks like it might work, but you're defining too many new variables\nmake it cleaner and more readable"}, {"role": "assistant", "content": "Sure, here's a modified version that does the same thing without defining unnecessary variables:\n\n```\ndef __init__(self, master):\n    ...\n    self.input_box.bind(\"<FocusOut>\", lambda event: self.toggle_box_focus(focused_box=self.input_box))\n    self.chat_box.bind(\"<FocusOut>\", lambda event: self.toggle_box_focus(focused_box=self.chat_box))\n    self.input_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus(focused_box=self.input_box))\n    self.chat_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus(focused_box=self.chat_box))\n\ndef toggle_box_focus(self, event=None, focused_box=None):\n    unfocused_box = self.input_box if focused_box == self.chat_box else self.chat_box\n    if focused_box == self.input_box:\n        self.chat_box.config(background=\"#111\")\n        self.input_box.config(background=\"#000\")\n    else:\n        self.input_box.config(background=\"#111\")\n        self.chat_box.config(background=\"#000\")\n\n    for widget in (self.input_box, self.chat_box):\n        widget.unbind(\"<FocusIn>\")\n        widget.unbind(\"<FocusOut>\")\n    \n    self.selected_box = focused_box\n    self.selected_box.focus_set()\n\n    focused_box.bind(\"<FocusOut>\", lambda event: self.toggle_box_focus(focused_box=unfocused_box))\n    focused_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus(focused_box=focused_box))\n    unfocused_box.bind(\"<FocusOut>\", lambda event: self.toggle_box_focus(focused_box=focused_box))\n    unfocused_box.bind(\"<FocusIn>\", lambda event: self.toggle_box_focus(focused_box=unfocused_box))\n```\n\nIn this version, we pass the currently focused box as an argument to the `toggle_box_focus()` function, instead of using a class variable `self.is_input_box_focused`. We get the unfocused box by checking the `focused_box` variable and assigning the opposite box to the `unfocused_box` variable.\n\nThen, we change the background colors of the boxes based on which one is currently focused. After that, we unbind the `<FocusIn>` and `<FocusOut>` events on both boxes to avoid registering multiple bindings.\n\nNext, we set the `self.selected_box` variable to the focused box and focus it. Finally, we rebind the `<FocusIn>` and `<FocusOut>` events on both boxes, with the appropriate function calls to `toggle_box_focus()`.\n\nThis way, the code is more concise and easier to understand."}, {"role": "user", "content": "what about making it more general? make all selected Text object backgrounds #111 deselected #000, and then reduce ctrl-e to this:\n\n    def toggle_box_focus(self, event=None):\n        if self.selected_box == self.input_box:\n            self.chat_box.focus_set()\n        elif self.selected_box == self.chat_box:\n            self.input_box.focus_set()"}, {"role": "assistant", "content": "Sure thing! Here's the modified code that sets all selected text objects to have a background of `#111`, and reduces the `toggle_box_focus()` function to just switching focus between the input and chat text boxes.\n\n```\ndef __init__(self, master):\n    ...\n    self.input_box.bind(\"<FocusOut>\", self.toggle_box_background)\n    self.chat_box.bind(\"<FocusOut>\", self.toggle_box_background)\n    self.input_box.bind(\"<FocusIn>\", self.toggle_box_background)\n    self.chat_box.bind(\"<FocusIn>\", self.toggle_box_background)\n\ndef toggle_box_background(self, event=None):\n    for widget in (self.input_box, self.chat_box):\n        if widget == self.selected_box:\n            widget.config(background=\"#111\")\n        else:\n            widget.config(background=\"#000\")\n\ndef toggle_box_focus(self, event=None):\n    if self.selected_box == self.input_box:\n        self.chat_box.focus_set()\n    elif self.selected_box == self.chat_box:\n        self.input_box.focus_set()\n```\n\nIn this version, we add the `toggle_box_background()` function that sets the background color of each text box based on whether or not it's currently selected.\n\nWe bind this function to `<FocusOut>` and `<FocusIn>` events for both text boxes to update the background color whenever a box is selected or deselected.\n\nLastly, we reduce the `toggle_box_focus()` function to just switch the focus between input and chat text boxes. Now, as desired, `Ctrl-E` can be used to toggle focus, while clicking inside either input text box or chat text box will automatically select it and set its background color."}, {"role": "user", "content": "self.input_box.bind(\"<FocusOut>\", self.toggle_box_background)\n        self.input_box.bind(\"<FocusIn>\", self.toggle_box_background)\n\ncan these two lines be reduced to a single line somehow"}, {"role": "assistant", "content": "Yes, you can use the `bindtags()` method to achieve that. \n\nWe can give each text box a specific `bind tag` when they are created using the `bindtags()` method, and then bind the focus events to a single function that handles them all at once.\n\n```\ndef __init__(self, master):\n    ...\n    input_box_bind_tags = tuple(self.input_box.bindtags())\n    self.input_box.bindtags((input_box_bind_tags[1],) + input_box_bind_tags)\n    self.input_box.bind_class(input_box_bind_tags[1], \"<FocusIn>\", self.toggle_box_background)\n    self.input_box.bind_class(input_box_bind_tags[1], \"<FocusOut>\", self.toggle_box_background)\n\n    chat_box_bind_tags = tuple(self.chat_box.bindtags())\n    self.chat_box.bindtags((chat_box_bind_tags[1],) + chat_box_bind_tags)\n    self.chat_box.bind_class(chat_box_bind_tags[1], \"<FocusIn>\", self.toggle_box_background)\n    self.chat_box.bind_class(chat_box_bind_tags[1], \"<FocusOut>\", self.toggle_box_background)\n```\n\nIn this version, we get the existing `bind tags` for each text box and add a new tag at the beginning using the tuple concatenation `+` operator. We then use the `bind_class()` method to bind `<FocusIn>` and `<FocusOut>` events to the new tag.\n\nUsing this technique, we can reduce the two original lines of code for each text box down to two lines total for both text boxes. Notice that the `toggle_box_background()` function remains the same."}, {"role": "user", "content": "alter toggle_box_background to take in a box param, and check whether the event that called it was FocusIn or FocusOut"}, {"role": "assistant", "content": "Sure, here's the updated `toggle_box_background()` function, which takes in a text box as a parameter and checks whether the event that called it was a `FocusIn` or `FocusOut` event:\n\n```\ndef toggle_box_background(self, box, event):\n    if event.type == \"9\":  # 9 is the integer value for 'FocusIn'\n        for widget in (self.input_box, self.chat_box):\n            if widget == box:\n                widget.config(background=\"#111\")\n            else:\n                widget.config(background=\"#000\")\n    elif event.type == \"10\":  # 10 is the integer value for 'FocusOut'\n        box.config(background=\"#000\")\n```\n\nIn this version, we added the `event` parameter to the function, which represents the focus event that called the function. Then, we check the `type` attribute of the `event` object to determine whether the event is a `FocusIn` or `FocusOut` event.\n\nIf the event is a `FocusIn` event, the function sets the background color of each text box based on whether it's the current `box` parameter or not, similar to the previous version. If the event is a `FocusOut` event, the function sets the background color of the `box` parameter to `#000` to indicate that it's no longer selected.\n\nWe also updated the function to take in a `box` parameter instead of iterating through all the text boxes, as requested. With this change, we no longer need the `bindtags()` method in the `__init__()` function, so it can be removed."}, {"role": "user", "content": "def toggle_bg_colour(self, box, event=None):\n        if event.type == \"9\": \n            box.config(background=\"#111\")\n        elif event.type == \"10\": \n            box.config(background=\"#000\")\n\nAttributeError: 'NoneType' object has no attribute 'type'\n\nwhy?"}, {"role": "assistant", "content": "This error occurs when the `event` parameter passed to `toggle_bg_colour()` is `None`. In this case, it means that the event argument is not being passed correctly to the function.\n\nTo fix this, we can modify the bindings for the `\"<FocusIn>\"` and `\"<FocusOut>\"` events to pass the text box object along with the event object to the `toggle_bg_colour()` function.\n\nHere's an example of how to modify the bindings:\n\n```\nself.chat_box.bind(\"<FocusIn>\", lambda event, box=self.chat_box: self.toggle_bg_colour(box, event))\nself.chat_box.bind(\"<FocusOut>\", lambda event, box=self.chat_box: self.toggle_bg_colour(box, event))\nself.input_box.bind(\"<FocusIn>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\nself.input_box.bind(\"<FocusOut>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n```\n\nIn this example, we're using `lambda` functions to pass the correct arguments to `toggle_bg_colour()`. The `box=self.chat_box` syntax sets the `box` parameter to the corresponding text box object, while `event` is passed automatically by the `bind()` method.\n\nThis way, the `event` parameter should always be valid and the `NoneType` error should be resolved."}]