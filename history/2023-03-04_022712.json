[{"role": "system", "content": "Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom chatgpt import GPT\nfrom datetime import datetime\nfrom json_search import get_files\nimport threading\nimport json\nimport os\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#000\")\n        master.bind('<F5>', self.new_history)\n        master.bind('<Control-f>', self.filter_history)\n        \n        self.preprompt = \"Prioritize accuracy, clarity, eloquence, and brevity. Ask questions and suggest interesting ideas when appropriate.\"\n        self.engine = \"gpt-3.5-turbo\"\n\n        self.history_dir = 'history/'\n        self.all_json_files = sorted([f for f in os.listdir(self.history_dir) if f.startswith(\"history_\")], reverse=True)\n        self.history_menu_var = StringVar()\n        self.history_menu_var.set(\"History\")\n        \n        self.chat_box = Text(master, wrap=WORD, width=80, height=20, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.chat_box.grid(row=0, column=0, sticky=N+S+E+W)\n        self.chat_box.tag_configure(\"user\", foreground=\"#555\")\n        self.chat_box.tag_configure(\"bot\", foreground=\"#997755\")\n        self.chat_box.tag_configure(\"system\", foreground=\"#6666ff\")\n\n        self.input_box = Text(master, wrap=WORD, width=80, height=1, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14))\n        self.input_box.config(insertbackground=\"#888\")\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=8, pady=8)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        self.input_box.focus_set()\n        \n        self.new_history()\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#997755')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#997755')\n        \n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        \n        self.populate_history(self.all_json_files)\n\n        master.config(menu=self.menu)\n\n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n    def gpt_call(self, engine, history):\n        response = GPT(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_history()\n        self.master.after(0, self.display_history)\n        \n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 10))\n        self.chat_box.see(END)\n        \n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n        \n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_history()\n        self.display_history()\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history))\n        t.start()\n        return \"break\"\n\n    # HISTORY FUNCTIONS\n    \n    def update_title(self):\n        file_size = round(os.path.getsize(f'{self.history_file}') / 1024, 1)\n        self.master.title(f\"{self.history_file} ({file_size} KB)\")\n    \n    def new_history(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.history_file = f\"{self.history_dir}history_{datetime.now().strftime('%Y-%m-%d_%H%M%S')}.json\"\n        self.display_history()\n        \n    def save_history(self):\n        with open(self.history_file, 'w') as f:\n            json.dump(self.history, f)\n        self.update_title()\n\n    def load_history(self, filename):\n        with open(self.history_dir + filename, 'r') as f:\n            self.history = json.load(f)\n        self.history_file = filename\n        self.display_history()\n        self.update_title()\n\n    def display_history(self):\n        self.chat_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.chat_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.chat_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.chat_box.see(END)\n\n    def filter_history(self, event=None):\n        query = simpledialog.askstring(\"Search\", \"Filter:\")\n        if query:\n            matching_files = get_files(f'{os.getcwd()}/history', query)\n            if matching_files:\n                self.populate_history(matching_files)\n        else:\n            self.populate_history(self.all_json_files)\n\n    def populate_history(self, files):    \n        self.history_menu.delete(0, END)\n        for f in files:\n            file_size = round(os.path.getsize(f'history/{f}') / 1024, 1)\n            self.history_menu.add_command(label=f\"{f} ({file_size} KB)\", command=lambda hf=f: self.load_history(hf))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "\n\n\nThis is a Python script that runs a simple chatbot interface using the GPT-3.5 Turbo engine from OpenAI. It allows the user to type messages into an input box, and the chatbot will respond with text generated by the GPT engine. The chat history is saved in JSON files in a \"history\" directory, which can be accessed through a drop-down menu. \n\nThe code is well-organized and easy to read. The UI is simple but effective, with clear text boxes for the conversation and input. The inclusion of keyboard shortcuts is a nice touch. The use of separate files for chat history is a good idea, and the filtering function makes it easy to find specific conversations. \n\nImprovements that could be made include adding more options for the GPT engine and allowing users to switch between them. Additionally, the chatbot currently responds after the user presses the \"Return\" key, but it may be more intuitive to make it respond automatically after a certain period of inactivity. Finally, including options for saving chat transcripts in different formats besides JSON could also be useful."}, {"role": "user", "content": "Exception in Tkinter callback\nTraceback (most recent call last):\n  File \"C:\\Users\\Adam\\AppData\\Local\\Programs\\Python\\Python38\\lib\\tkinter\\__init__.py\", line 1883, in __call__\n    return self.func(*args)\n  File \"C:\\Users\\Adam\\Desktop\\OpenAI\\ChatGPT-A\\LocalChat\\localchat.py\", line 139, in <lambda>\n    self.menu.add_cascade(label=f\"History ({len(files)})\", menu=self.history_menu)\n  File \"C:\\Users\\Adam\\Desktop\\OpenAI\\ChatGPT-A\\LocalChat\\localchat.py\", line 111, in load_history\n    def display_history(self):\n  File \"C:\\Users\\Adam\\Desktop\\OpenAI\\ChatGPT-A\\LocalChat\\localchat.py\", line 91, in update_title\n    file_size = round(os.path.getsize(f'{self.history_file}') / 1024, 1)\n  File \"C:\\Users\\Adam\\AppData\\Local\\Programs\\Python\\Python38\\lib\\genericpath.py\", line 50, in getsize\n    return os.stat(filename).st_size\nFileNotFoundError: [WinError 2] The system cannot find the file specified: 'history_2023-03-03_203725.json'"}, {"role": "assistant", "content": "This error is likely occurring because the program is attempting to access a file that does not exist or has been moved. It appears to be trying to access a file called \"history_2023-03-03_203725.json\", which has not been created yet. \n\nIt's possible that this error is being triggered by the code trying to access a file that was deleted or moved, or it could be due to a bug or error in the program logic. \n\nOne way to resolve this issue would be to modify the code so that it checks whether the file exists before trying to access it. This could be done using the `os.path.isfile()` method in Python. \n\nAlternatively, you could try creating a new chat history file with a current timestamp to see if that resolves the issue."}, {"role": "user", "content": "self.history_file should always be the filename of the current file, but i also don't want to create new empty files every time the program starts. instead i only want to make a new file when user enters input for the first time. help me figure out how to do this better."}, {"role": "assistant", "content": "One way to modify the code so that it creates a new chat history file only when the user enters their first input would be to check whether a history file already exists when the `send_message()` method is called. If a file does not exist, the method can create a new file with a current timestamp and add the system prompt to it. If a file does exist, the method can simply append the user's input and the chatbot's response to the existing file.\n\nHere's one way to modify the `send_message()` method to achieve this:\n\n```\ndef send_message(self, event=None):\n    in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n    self.input_box.config(height=1)\n    self.input_box.delete(\"1.0\", END)\n    self.input_box.update_idletasks()\n\n    # Check if chat history file already exists\n    if os.path.isfile(self.history_file):\n        with open(self.history_file, 'r') as f:\n            self.history = json.load(f)\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history))\n    else:\n        # Create new chat history file\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.history_file = f\"{self.history_dir}history_{datetime.now().strftime('%Y-%m-%d_%H%M%S')}.json\"\n        with open(self.history_file, 'w') as f:\n            json.dump(self.history, f)\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, self.history[1:]))\n\n    self.history.append({\"role\": \"user\", \"content\": in_content})\n    self.save_history()\n    self.display_history()\n\n    t.start()\n    return \"break\"\n```\n\nThis modified code checks if a chat history file already exists. If it does exist, it loads the contents of the file into `self.history` and initiates a chatbot response using those existing contents. If a history file does not exist, it creates a new one with the current timestamp, adds the system prompt to it, and initiates the chatbot response using an empty `self.history` list (except for the system prompt).\n\nNote also that when initiating the chatbot response thread (`t`), we passed only `self.history[1:]` instead of `self.history` to avoid the initial prompt being passed to the GPT-3 engine again."}]