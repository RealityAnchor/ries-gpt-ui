[{"role": "system", "content": "Be clear and accurate. When listing items, do not describe them. When writing code, include only the lines you add, delete, or change."}, {"role": "user", "content": "from tkinter import *\nfrom tkinter import simpledialog\nfrom datetime import datetime\nfrom json_search import get_filenames\nimport threading\nimport gpt_api\nimport tiktoken\nimport json\nimport os\nimport re\n\nclass ChatBot:\n    def __init__(self, master):\n        self.master = master\n        master.title(\"ChatGPT\")\n        master.state(\"zoomed\")\n        master.configure(bg=\"#222\")\n\n        self.preprompt = \"Be clear and accurate. When listing items, do not describe them. When writing code, include only the lines you add, delete, or change.\"\n        self.engine = \"gpt-3.5-turbo\"\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.encoding = tiktoken.encoding_for_model(self.engine)\n        self.max_tokens = 3000 # 4096 - max_tokens = floor of maximum response length\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.filename = self.timestamp\n        \n        self.border_size = 8\n        self.thread_box = Text(master, wrap=WORD, fg=\"#555\", bg=\"#000\", font=(\"Arial\", 14), state=DISABLED)\n        self.thread_box.bind(\"<FocusIn>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.bind(\"<FocusOut>\", lambda event, box=self.thread_box: self.toggle_bg_colour(box, event))\n        self.thread_box.grid(row=0, column=0, sticky=N+S+E+W, padx=self.border_size, pady=self.border_size)\n        self.thread_box.tag_configure(\"user\", foreground=\"#555\")\n        self.thread_box.tag_configure(\"bot\", foreground=\"#975\")\n        self.thread_box.tag_configure(\"system\", foreground=\"#66f\")\n        self.thread_box.tag_configure(\"highlight\", background=\"#66f\", foreground=\"#000\")\n\n        self.input_box = Text(master, wrap=WORD, height=1, fg=\"#888\", bg=\"#000\", font=(\"Arial\", 14), insertbackground=\"#888\")\n        self.input_box.bind(\"<FocusIn>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.bind(\"<FocusOut>\", lambda event, box=self.input_box: self.toggle_bg_colour(box, event))\n        self.input_box.grid(row=1, column=0, sticky=N+S+E+W, padx=self.border_size, pady=(0,self.border_size))\n        self.input_box.focus_set()\n        \n        master.grid_columnconfigure(0, weight=1)\n        master.grid_rowconfigure(0, weight=1)\n        master.grid_rowconfigure(1, weight=0)\n\n        # KEYBOARD SHORTCUTS\n        self.input_box.bind(\"<Return>\", self.send_message)\n        self.input_box.bind(\"<Shift-Return>\", self.input_newline)\n        self.input_box.bind(\"<KeyRelease>\", self.resize_input)\n        master.bind('<Control-e>', self.toggle_box_focus)\n        master.bind('<Control-f>', self.find_string)\n        master.bind('<Control-h>', self.history_filter)\n        master.bind('<Control-s>', self.rename_thread)\n        master.bind('<F5>', self.new_conversation)\n        master.bind('<F11>', self.toggle_fullscreen)\n\n        master.option_add('*Menu*activeBackground', '#333')\n        master.option_add('*Menu*activeForeground', '#975')\n        master.option_add('*Menu*background', '#000')\n        master.option_add('*Menu*foreground', '#975')\n\n        self.menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        master.config(menu=self.menu)\n        self.history_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        self.fav_menu = Menu(master, background='#333', foreground='#FFF', activebackground='#555', activeforeground='#FFF')\n        \n        self.new_conversation()\n\n    def gpt_call(self, engine, history):\n        response = gpt_api.call(engine, history)\n        out_content = response[\"choices\"][0][\"message\"][\"content\"]\n        re_tokens = response[\"usage\"][\"total_tokens\"]\n        self.history.append({\"role\": \"assistant\", \"content\": out_content})\n        self.save_file()\n        self.master.after(0, self.update_display)\n\n    # Return\n    def send_message(self, event=None):\n        in_content = f'{self.input_box.get(\"1.0\", \"end\").strip()}'\n        self.input_box.config(height=1)\n        self.input_box.delete(\"1.0\", END)\n        self.input_box.update_idletasks()\n        self.history.append({\"role\": \"user\", \"content\": in_content})\n        self.save_file()\n        self.update_display()\n\n        # slice oldest messages from overly long threads\n        token_lengths = [len(self.encoding.encode(entry[\"content\"])) for entry in self.history]\n        while sum(token_lengths) > self.max_tokens:\n            token_lengths.pop(0)\n        n = len(token_lengths)\n        sliced_history = self.history[-n:]\n\n        t = threading.Thread(target=self.gpt_call, args=(self.engine, sliced_history))\n        t.start()\n        return \"break\"\n\n    # Shift-Return\n    def input_newline(self, event=None):\n        self.input_box.insert(INSERT, '\\n')\n        return \"break\"\n\n    # Ctrl-E\n    def toggle_box_focus(self, event=None):\n        if self.master.focus_get() == self.input_box:\n            self.thread_box.focus_set()\n        else:\n            self.input_box.focus_set()\n\n    # Ctrl-F\n    def find_string(self, event=None):\n        query = simpledialog.askstring(\"Find String\", \"\")\n        if query:\n            index = \"1.0\"\n            first_match_index = None\n            while True:\n                index = self.thread_box.search(query, index, nocase=True, stopindex=END)\n                if not index:\n                    break\n                end_index = f\"{index}+{len(query)}c\"\n                self.thread_box.tag_add(\"highlight\", index, end_index)\n                if first_match_index is None:\n                    first_match_index = index\n                index = end_index\n            if first_match_index is not None:\n                self.thread_box.see(first_match_index)\n\n    # Ctrl-H\n    # searches json files for a string\n    def history_filter(self, event=None):\n        query = simpledialog.askstring(\"History Filter\", \"\")\n        if query:\n            matching_filenames = get_filenames(f'history', query)\n            if matching_filenames:\n                self.populate_history(matching_filenames)\n        else:\n            self.populate_history(self.json_files)\n            \n    # Ctrl-S\n    def rename_thread(self, event=None):\n        old_filename = self.filename\n        new_filename = simpledialog.askstring(\"Rename Conversation\", \"\")\n        if new_filename:\n            # check for duplicates\n            existing_files = [f.rsplit(\".\", 1)[0] for f in os.listdir('history')]\n            i = 2\n            while new_filename in existing_files:\n                new_filename = f\"{new_filename.rsplit('_', 1)[0]}_{i}\"\n                i += 1\n\n            # rename file and update menu\n            os.rename(f\"history/{old_filename}.json\", f\"history/{new_filename}.json\")\n            self.filename = new_filename\n            self.save_file()\n            self.json_files = self.load_json_filenames('history')\n            self.populate_history(self.json_files)\n\n    # F5\n    def new_conversation(self, event=None):\n        self.history = [{\"role\": \"system\", \"content\": self.preprompt}]\n        self.timestamp = datetime.now().strftime('%Y-%m-%d_%H%M%S')\n        self.filename = self.timestamp\n        self.json_files = self.load_json_filenames('history')\n        self.populate_history(self.json_files)\n        self.update_display()\n\n    # F11\n    def toggle_fullscreen(self, event=None):\n        self.master.attributes('-fullscreen', not self.master.attributes('-fullscreen'))\n\n    # Key-Release\n    def resize_input(self, event=None):\n        num_lines = int(self.input_box.index('end-1c').split('.')[0])\n        self.input_box.config(height=min(num_lines, 12))\n\n\n    def toggle_bg_colour(self, box, event=None):\n        if event.type == \"9\": # <FocusIn>\n            box.config(background=\"#111\")\n        elif event.type == \"10\": # <FocusOut>\n            box.config(background=\"#000\")\n\n    def update_title(self, filename):\n        file_size = round(os.path.getsize(f'history/{filename}.json') / 1024, 1)\n        self.master.title(f\"{filename} ({file_size} KB)\")\n\n    def save_file(self):\n        with open(f'history/{self.filename}.json', 'w') as f:\n            json.dump(self.history, f)\n        self.update_title(self.filename)\n\n    def load_file(self, filename):\n        with open(f'history/{filename}.json', 'r') as f:\n            self.history = json.load(f)\n        self.json_files = self.load_json_filenames('history')\n        self.filename = filename\n        self.populate_history(self.json_files)\n        self.update_display()\n        self.update_title(filename)\n\n    def load_json_filenames(self, directory):\n        return [file for file in os.listdir(f'{directory}/') if file.endswith(\".json\")]\n\n    def update_display(self):\n        self.thread_box.config(state=NORMAL)\n        self.thread_box.delete(\"1.0\", END)\n        for entry in self.history:\n            role = entry[\"role\"]\n            content = entry[\"content\"]\n            if role == \"system\":\n                self.thread_box.insert(END, f\"{content}\", \"system\")\n            elif role == \"user\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"user\")\n            elif role == \"assistant\":\n                self.thread_box.insert(END, f\"\\n\\n{content}\", \"bot\")\n        self.thread_box.config(state=DISABLED)\n        self.thread_box.see(END)\n\n    def populate_history(self, filename_list):\n        self.history_menu.delete(0, END)\n        self.fav_menu.delete(0, END)\n        history_count = 0\n        fav_count = 0\n        for filename in sorted(filename_list, reverse=True):\n            file_size = round(os.path.getsize(f'history/{filename}') / 1024, 1)\n            if re.match(r'\\d{4}-\\d{2}-\\d{2}_\\d{6}', filename):\n                menu = self.history_menu\n                history_count += 1\n            else:\n                menu = self.fav_menu\n                fav_count += 1\n            filename = filename.replace('.json', '')\n            menu.add_command(label=f\"{filename} ({file_size} KB)\", command=lambda name=filename: self.load_file(name))\n        self.menu.delete(0, END)\n        self.menu.add_cascade(label=f\"History ({history_count})\", menu=self.history_menu)\n        self.menu.add_cascade(label=f\"Favourites ({fav_count})\", menu=self.fav_menu)\n\nroot = Tk()\nmy_gui = ChatBot(root)\nroot.mainloop()"}, {"role": "assistant", "content": "The code defines a GUI for a chatbot that uses the GPT-3.5-Turbo language model to generate responses to user input. The GUI consists of a thread box displaying the conversation history, an input box for the user to input text, and menus that allow the user to toggle between different conversation threads and save the current conversation. The chatbot is implemented as a class with various methods for handling user input and updating the display. The code also imports several modules, including tkinter, datetime, json, and os, among others."}, {"role": "user", "content": "can tkinter text boxes use ctrl-z? would i have to write a ctrl-z method myself?"}, {"role": "assistant", "content": "Yes, the `Text` widget in tkinter supports undo with the default `Control + Z` shortcut. You don't need to write your own method for undo."}, {"role": "user", "content": "it isn't working. why not?"}, {"role": "assistant", "content": "The `Control + Z` shortcut for undo is only supported if the widget has the focus. So make sure that the `Text` widget is in focus when you press `Control + Z`. If another widget has the focus, you will need to click on the `Text` widget to give it focus before `Control + Z` will work.\n\nAdditionally, undo may be disabled if `undo` option is set to `False` or if there are no changes left to undo. You can check the value of `undo` option for your `Text` widget by calling the `cget` method:\n\n```python\ncan_undo = my_text_widget.cget(\"undo\")\nprint(can_undo)\n```\n\nIf `can_undo` is `False`, try setting the `undo` option to `True` by calling the `config` method:\n\n```python\nmy_text_widget.config(undo=True)\n```\n\nThis should enable undo for your `Text` widget."}, {"role": "user", "content": "list more config options for text manipulation like undo=True"}, {"role": "user", "content": "list more config options for text manipulation like undo=True"}, {"role": "user", "content": "list more config options for text manipulation like undo=True"}, {"role": "assistant", "content": "Sure, here are some more `Text` widget configuration options for text manipulation:\n\n- `autoseparators`: If set to `True`, the widget automatically inserts separators (such as spaces and punctuation) when the user types text. The default is `True`.\n- `blockcursor`: If set to `True`, the widget displays a block cursor instead of a line cursor. The default is `False`.\n- `height`: The height of the widget in text units (not pixels). Use this option to set the initial size of the widget.\n- `insertofftime`: The time in milliseconds before the insertion cursor should disappear when not blinking. The default is `300`.\n- `insertontime`: The time in milliseconds before the insertion cursor should blink on and off. The default is `600`.\n- `insertwidth`: The width of the insertion cursor in pixels. The default is `2`.\n- `maxundo`: The maximum number of undo levels to keep in memory. The default is `None`, which means unlimited undo levels.\n- `selectbackground`: The background color to use when text is selected. The default is the system highlight color.\n- `selectborderwidth`: The width of the selection border in pixels. The default is `0`, which means no border.\n- `selectforeground`: The foreground color to use when text is selected. The default is the system highlight text color.\n- `state`: The state of the widget, either 'normal', 'disabled', or 'readonly'. Use this option to prevent the user from modifying the text.\n- `width`: The width of the widget in character units (not pixels). Use this option to set the initial size of the widget.\n\nThere are many more configuration options available for the `Text` widget that control various aspects of its appearance and behavior. You can find a full list of configuration options in the tkinter documentation."}, {"role": "user", "content": "are there any that automatically resize height to fit text?"}, {"role": "assistant", "content": "Yes, there is a configuration option that allows the `Text` widget to adjust its height to fit its contents. The option is called `height` and it must be set to 0 to enable this behavior.\n\nWhen the `height` option is set to 0, the widget will automatically adjust its height to fit the contents of the text it contains. Note that if the `wrap` option is set to 'none', the widget will not be able to adjust its height to fit its contents.\n\nHere is an example of using the `height` option to automatically resize the widget:\n\n```python\nimport tkinter as tk\n\nroot = tk.Tk()\n\n# create a Text widget with height=0 to allow it to resize automatically\nmy_text_widget = tk.Text(root, height=0)\n\n# pack the widget so that it fills the available space\nmy_text_widget.pack(fill='both', expand=True)\n\nroot.mainloop()\n```\n\nWith this code, the `Text` widget will resize its height to fit its contents as you add or remove text."}, {"role": "user", "content": "_tkinter.TclError: cannot use geometry manager pack inside . which already has slaves managed by grid\n\nis the .pack() line required?\ncan i resize input_box automatically some other way?"}, {"role": "assistant", "content": "The `.pack()` line is not necessarily required, but it depends on your desired layout. The error you're seeing occurs when you try to use both the `pack` and `grid` geometry managers to lay out widgets in the same parent widget. Each geometry manager has its own rules for laying out widgets, and they cannot be used interchangeably.\n\nIf you're using the `Grid` geometry manager to lay out your other widgets, you should also use `Grid` to lay out your `input_box`. You can use the `Grid` method's `sticky` parameter to make the `input_box` fill horizontally as the window is resized. Here's an example:\n\n```python\nimport tkinter as tk\n\nroot = tk.Tk()\n\n# create a label and text widget with the grid geometry manager\nlabel = tk.Label(root, text=\"Enter text:\")\nlabel.grid(row=0, column=0)\n\ninput_box = tk.Text(root, height=1)\ninput_box.grid(row=0, column=1, sticky=\"ew\")\n\nroot.mainloop()\n```\n\nNotice that we're passing the `sticky=\"ew\"` parameter to the `grid` method, which tells it to expand the `input_box` widget to fill the horizontal space available to it.\n\nIf you don't want to use the `grid` method, another option is to bind the `<Configure>` event of the `Text` widget to a function that resizes the widget whenever the window is resized. Here's an example:\n\n```python\nimport tkinter as tk\n\nroot = tk.Tk()\n\n# create a label and text widget with the pack geometry manager\nlabel = tk.Label(root, text=\"Enter text:\")\nlabel.pack(side=\"left\")\n\ninput_box = tk.Text(root, height=1)\ninput_box.pack(side=\"left\", fill=\"x\", expand=True)\n\n# bind the <Configure> event to a function that resizes the input_box\ndef resize_input_box(event):\n    input_box.config(height=event.width // 10)\n\ninput_box.bind(\"<Configure>\", resize_input_box)\n\nroot.mainloop()\n```\n\nIn this example, we're using the `pack` geometry manager to lay out the widgets, and we're binding the `<Configure>` event to a function called `resize_input_box`. This function resizes the `input_box` widget's height based on its current width. You'll need to experiment with the appropriate formula for resizing the height to fit your text widget."}]